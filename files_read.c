#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "stat.h"

int load_text(const char* filename, int*** ptr) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        return 2;
    }

    char ch;

    // читаем файл посимвольно и проверяем, чтобы там не было ничего, кроме цифр, знака "минус",
    // пробела или символов конца строки
    while (fscanf(file, "%c", &ch) == 1) {
        if (!isdigit(ch) && ch !='\0'  && ch !=' ' && ch !='\r' && ch !='\n' && ch !='-') {
            fclose(file);
            return 3;
        }
    }

    // переходим на начало файла
    rewind(file);

    // колисчество строк и столбцов в будущем двумерном массиве
    int rows = 0, cols = 0;
    // переменная, в которую будем читать очередное число из файла
    int val;

    // первый раз читаем файл, но никуда ничего не записываем, а просто считаем количество элементов,
    // и определяем количество строк будущего двумерного массива, чтобы потом
    // выделить ровно столько памяти, сколько нужно для хранения данных из файла

    // читаем из файла sizeof(int), пока читается
    while (fscanf(file, "%d", &val) == 1) {
        // если прочитали значение -1 - по условию задания это признак конца строки
        // увеличиваем количество строк на 1, обнуляем количество столбцов
        if (val == -1) {
            rows++;
            cols = 0;
            // иначе (если прочитанное значение не указывает на то, что это конец строки)
            // увеличиваем количество столбцов на 1
        } else {
            cols++;
        }
    }

    // если оба значения (колонки и строки) равны 0, значит файл был пустой
    if (rows == 0 && cols == 0) {
        fclose(file);
        return 3;
    }

    // если последнее прочитанное из файла значение не -1, то считаем, что в файле ошибка
    if (val != -1) {
        fclose(file);
        return 3;
    }

    // входной параметр int*** ptr - это ссылка на двумерный массив int**,
    // значиит *ptr - это сам двумерный массив
    // выделяем под него память, как под массив указателей на int
    // количеством элементов массива будет количество строк двумерного массива +1
    *ptr = malloc((rows+1) * sizeof(int*));
    if (*ptr == NULL) {
        fclose(file);
        return 4;
    }
    // последним элементом этого массива будет NULL - и это будет признаком того, что массив закончился
    // будем это использовать, когда будем потом читать данные из массивы
    *((*ptr)+rows) = NULL;

    // мы прочитали весь файл, чтобы определить колиичество строк нашего двумерного массива int**
    // теперь возвращаемся на начало файла, чтобы снова читать оттуда данные, но теперь уже будем
    // для каждой строки определять колиичество элементов в строке
    rewind(file);

    rows = 0, cols = 0;
    // читаем из файла sizeof(int), пока читается
    // на этом проходе будем определять количество элементов в каждой строке,
    // чтобы выделить для них столько памяти, сколько нужно (не больше и не меньше)
    while (fscanf(file, "%d", &val) == 1) {
        // если прочитали значение -1 - по условию задания это признак конца строки
        if (val == -1) {
            // выделяем память под массив int под столько элементов, сколько мы насчитали чисет в сторке +1
            // последним элементом этого массива будет -1 и это будет признаком того, что массив закончился
            // будем это использовать, когда будем потом читать данные из массивы
            // запишем -1 в последний элемент, когда будем читать данные из файла, и записывать в массив
            *((*ptr)+rows) = malloc((cols+1) * sizeof(int));
            if (*((*ptr)+rows) == NULL) {
                destroy(ptr);
                fclose(file);
                return 4;
            }
            // увеличиваем номер текущей строки на 1, обнуляем количество чисел, которые насчитали в строке
            rows++;
            cols = 0;
            // если прочитали значение не -1, значит это обычное значение и надо увеличить количество элементов в строке на 1
        } else {
            cols++;
        }
    }


    // мы прочитали весь файл первый раз, чтобы определить колиичество строк нашего двумерного массива int**
    // потом вернулись на начало и прочитали его еще раз, определив количество чисел в кажной строке
    // мы закончили выделение памяти для массива
    // теперь опять возвращаемся на начало файла, чтобы снова читать оттуда данные, но теперь уже будем
    // записывать их в созданный двумерный массив (массив массивов)
    rewind(file);

    rows = 0, cols = 0;
    while (fscanf(file, "%d", &val) == 1) {
        // если прочитали значение -1 - по условию задания это признак конца строки
        if (val == -1) {
            // записываем -1 в  последний элемент строки
            *(*((*ptr)+rows)+cols) = -1;
            // увеличиваем номер текущей строки на 1, обнуляем количество чисел, которые насчитали в строке
            rows++;
            cols = 0;
            // если прочитали значение не -1, значит это обычное значение
        } else {
            // записываем прочитанное значение в текущий элемент текущей строки
            *(*((*ptr)+rows)+cols) = val;
            // увеличиваем номер текущего элемента строки на 1
            cols++;
        }
    }

    fclose(file);

    return 0;
}

int load_binary(const char* filename, int*** ptr) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        return 2;
    }

    // колисчество строк и столбцов в будущем двумерном массиве
    int rows = 0, cols = 0;
    // переменная, в которую будем читать очередное число из файла
    int val;

    // первый раз читаем файл, но никуда ничего не записываем, а просто считаем количество элементов,
    // и определяем количество строк будущего двумерного массива, чтобы потом
    // выделить ровно столько памяти, сколько нужно для хранения данных из файла

    // читаем из файла sizeof(int), пока читается
    while (fread(&val, sizeof(int), 1, file) == 1) {
        // если прочитали значение -1 - по условию задания это признак конца строки
        // увеличиваем количество строк на 1, обнуляем количество столбцов
        if (val == -1) {
            rows++;
            cols = 0;
        // иначе (если прочитанное значение не указывает на то, что это конец строки)
        // увеличиваем количество столбцов на 1
        } else {
            cols++;
        }
    }

    // если оба значения (колонки и строки) равны 0, значит файл был пустой
    if (rows == 0 && cols == 0) {
        fclose(file);
        return 3;
    }

    // если последнее прочитанное значение из файла не -1,
    // значит в конце последней строки не было значения -1, которое указывает на конец строки
    // но мы все равно увелечиваем количество строк на 1, чтобы последняя строка была учтена
    // например, если содержимое файла 1 2 -1 3 4 -1 5 6 -1, то будет количество строк = 3
    // а если 1 2 -1 3 4 -1 5 6, то будет количество строк = 2, а нам надо чтобы строк было 3
    if (val != -1) {
        rows++;
    }

    // входной параметр int*** ptr - это ссылка на двумерный массив int**,
    // значиит *ptr - это сам двумерный массив
    // выделяем под него память, как под массив указателей на int
    // количеством элементов массива будет количество строк двумерного массива +1
    *ptr = malloc((rows+1) * sizeof(int*));
    if (*ptr == NULL) {
        fclose(file);
        return 4;
    }
    // последним элементом этого массива будет NULL - и это будет признаком того, что массив закончился
    // будем это использовать, когда будем потом читать данные из массивы
    *((*ptr)+rows) = NULL;


    // мы прочитали весь файл, чтобы определить колиичество строк нашего двумерного массива int**
    // теперь возвращаемся на начало файла, чтобы снова читать оттуда данные, но теперь уже будем
    // для каждой строки определять колиичество элементов в строке
    rewind(file);

    rows = 0, cols = 0;
    // читаем из файла sizeof(int), пока читается
    // на этом проходе будем определять количество элементов в каждой строке,
    // чтобы выделить для них столько памяти, сколько нужно (не больше и не меньше)
    while (fread(&val, sizeof(int), 1, file) == 1) {
        // если прочитали значение -1 - по условию задания это признак конца строки
        if (val == -1) {
            // выделяем память под массив int под столько элементов, сколько мы насчитали чисет в сторке +1
            // последним элементом этого массива будет -1 и это будет признаком того, что массив закончился
            // будем это использовать, когда будем потом читать данные из массивы
            // запишем -1 в последний элемент, когда будем читать данные из файла, и записывать в массив
            *((*ptr)+rows) = malloc((cols+1) * sizeof(int));
            if (*((*ptr)+rows) == NULL) {
                destroy(ptr);
                fclose(file);
                return 4;
            }
            // увеличиваем номер текущей строки на 1, обнуляем количество чисел, которые насчитали в строке
            rows++;
            cols = 0;
        // если прочитали значение не -1, значит это обычное значение и надо увеличить количество элементов в строке на 1
        } else {
            cols++;
        }
    }

    // если последнее прочитанное значение из файла не -1,
    // значит в конце последней строки не было значения -1, которое указывает на конец строки
    // но нам все равно нужно выделить память под числа последней строки
    if (val != -1) {
        *((*ptr) + rows) = malloc((cols + 1) * sizeof(int));
        if (*((*ptr) + rows) == NULL) {
            destroy(ptr);
            fclose(file);
            return 4;
        }
    }

    // мы прочитали весь файл первый раз, чтобы определить колиичество строк нашего двумерного массива int**
    // потом вернулись на начало и прочитали его еще раз, определив количество чисел в кажной строке
    // мы закончили выделение памяти для массива
    // теперь опять возвращаемся на начало файла, чтобы снова читать оттуда данные, но теперь уже будем
    // записывать их в созданный двумерный массив (массив массивов)
    rewind(file);

    rows = 0, cols = 0;
    while (fread(&val, sizeof(int), 1, file) == 1) {
        // если прочитали значение -1 - по условию задания это признак конца строки
        if (val == -1) {
            // записываем -1 в  последний элемент строки
            *(*((*ptr)+rows)+cols) = -1;
            // увеличиваем номер текущей строки на 1, обнуляем количество чисел, которые насчитали в строке
            rows++;
            cols = 0;
        // если прочитали значение не -1, значит это обычное значение
        } else {
            // записываем прочитанное значение в текущий элемент текущей строки
            *(*((*ptr)+rows)+cols) = val;
            // увеличиваем номер текущего элемента строки на 1
            cols++;
        }
    }

    // если последнее прочитанное значение из файла не -1,
    // значит в конце последней строки не было значения -1, которое указывает на конец строки
    // но нам все равно нужно в наш массив в последний элемент последней строки записать -1
    if (val != -1) {
        *(*((*ptr)+rows)+cols) = -1;
    }

    fclose(file);
    return 0;
}

int load(const char* filename, int*** ptr, enum save_format_t format) {
    if (ptr == NULL || filename == NULL) {
        return 1;
    }
    if (format != fmt_binary && format != fmt_text) {
        return 1;
    }

    if (format == fmt_text) {
        return load_text(filename, ptr);
    }
    return load_binary(filename, ptr);
}